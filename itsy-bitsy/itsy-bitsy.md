# itsy-bitsy

This was a very interesting challenge which required very careful analysis of the code provided to figure out exactly what was required to exploit it.

The challenge provides us with a python program which is used to encrypt the flag and an address to connect to. Upon connecting the service asks for 2 user inputs which must be integers and with the restriction that the first integer must be greater than 0 and the second integer must be greater than the first. Using these inputs the service encrypts the message and returns the ciphertext as a binary string.

The algorithm used to encrypt the flag is an XOR applied to the individual bits of the binary representation of the flag. The implementation provide is:
```python
def bit_str_xor(bit_str_1, bit_str_2):
    xor_res = ''
    for i in range(len(bit_str_1)):
        bit_1 = bit_str_1[i]
        bit_2 = bit_str_2[i]
        xor_res += str(int(bit_1) ^ int(bit_2))
    return xor_res
```
An important thing to note that the length of the plaintext in bits will be the same as the length of the ciphertext. Counting the number of bits returned by the service we now that the length of the flag is 301 bits long.

Looking at the code provided this is how the user inpit gets used to encrpyt the flag:
```python
from Crypto.Random.random import randint

def str_to_bits(s):
    bit_str = ''
    for c in s:
        i = ord(c)
        bit_str += bin(i)[2:]
    return bit_str

def generate_random_bits(lower_bound, upper_bound, number_of_bits):
    bit_str = ''
    while len(bit_str) < number_of_bits:
        r = randint(lower_bound, upper_bound)
        bit_str += bin(r)[2:]
    return bit_str[:number_of_bits]

def main():
    with open('flag.txt','r') as f:
        flag = f.read()
    for c in flag:
        i = ord(c)
        assert i in range(2**6,2**7)
    flag_bits = str_to_bits(flag)
    i,j = recv_input()
    lb = 2**i
    ub = 2**j - 1
    n = len(flag_bits)
    random_bits = generate_random_bits(lb,ub,n)
    encrypted_bits = bit_str_xor(flag_bits,random_bits)
    print(f'Ciphertext: {encrypted_bits}')
```
The two numbers that get inputted, *i and j* are used to create a an lower and upper bound but raise 2 to the power of i and 2 to the power of j minus 1 respectively. These bounds passed to the `generate_random_bits(lower_bound, upper_bound, number_of_bits)` function which generated the key that gets passed to `bit_str_xor(bit_str_1, bit_str_2)` to encrypt the flag. The `generate_random_bits(lower_bound, upper_bound, number_of_bits)` will carry on generating random numbers until it has a bit string of length `number_of_bits`. The `randint(a,b)` function generates a random integer between a and b inclusive.

The other important function to take note of is the `bin()` function. This function returns a bit string of the integer provided without any trailing 0's. This means that the first bit of the bit string will always be 1. This is key to solving this challenge. 

What is evident is that though though the input will can control how many bits the random number generated by `randint(a,b)` is. For decimal number x can be represented by b bits if `2**(b-1) <= x <= 2**b -1`. For example, if we provide the input of i=3 and j=4 we will generate only 4 bit random numbers to make up the key. Since we know that the `bin()` function returns a bit string with the first bit as 1 we know that for an a 4 bit number the *1, 5, 9 ...* bits of the key will alway be 1. We can use this to recover the *1, 5, 9 ...* bits of the plaintext. If the *1, 5, 9 ...* of the ciphertext is 1 then the plaintext bit must be 0 since 0 XOR 1 = 0 and if the ciphertext bit is 0 then the plaintext bit must be 1 since 1 XOR 1 = 0.

Hence for use to solve this challenge we can use the following algorithm:
1. Start with an input of `i=1, j=2`. This will generate a key by repeating a 2 bit number.
2. Look at the 3rd bit and derive the third bit of the plaintext
3. Next increment i and j by 1 and repeat the process to recover the 4th bit of the plaintext
4. Continue until all bits are recovered.

The only bit that cannot be recovered this way is the first and second bit, but we know that these need to be 1 since the first letter of *flag* is *f* which what a binary representation of *1100110*

Note that a more efficient way to recover the plaintext is to only use keys that are a prime number of bits long. This is because a key of 7 bits for example can be used to recover the bit *8, 15, 22, ...*. This is how I implemented it in `decrypt.py` using all prime numbers less than 301.

Running `decrypt.py` gives the flag as: `flag{bits_leaking_out_down_the_water_spout}`