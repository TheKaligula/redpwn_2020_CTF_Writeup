# itsy-bitsy

This was a very interesting challenge which required very careful analysis of the code provided to figure out exactly what was required to exploit it.

The challenge provides us with a Python program, which is used to encrypt the flag, and an address to connect to. Upon connecting the service asks for 2 user inputs which must be integers with the restriction that the first integer be greater than 0 and the second integer be greater than the first. Using these inputs the service encrypts the message and returns the ciphertext as a binary string.

The algorithm used to encrypt the flag is an XOR applied to the individual bits of the binary representation of the flag. The implementation provided in the code is:
```python
def bit_str_xor(bit_str_1, bit_str_2):
    xor_res = ''
    for i in range(len(bit_str_1)):
        bit_1 = bit_str_1[i]
        bit_2 = bit_str_2[i]
        xor_res += str(int(bit_1) ^ int(bit_2))
    return xor_res
```
An important thing to note is that the length of the plaintext in bits will be the same as the length of the ciphertext in bits. Counting the number of bits returned by the service we know that the length of the flag is 301 bits long.

Looking at the code provided this is how the user input gets used to encrypt the flag:
```python
from Crypto.Random.random import randint

def str_to_bits(s):
    bit_str = ''
    for c in s:
        i = ord(c)
        bit_str += bin(i)[2:]
    return bit_str

def generate_random_bits(lower_bound, upper_bound, number_of_bits):
    bit_str = ''
    while len(bit_str) < number_of_bits:
        r = randint(lower_bound, upper_bound)
        bit_str += bin(r)[2:]
    return bit_str[:number_of_bits]

def main():
    with open('flag.txt','r') as f:
        flag = f.read()
    for c in flag:
        i = ord(c)
        assert i in range(2**6,2**7)
    flag_bits = str_to_bits(flag)
    i,j = recv_input()
    lb = 2**i
    ub = 2**j - 1
    n = len(flag_bits)
    random_bits = generate_random_bits(lb,ub,n)
    encrypted_bits = bit_str_xor(flag_bits,random_bits)
    print(f'Ciphertext: {encrypted_bits}')
```
The two numbers that get inputted, *i and j* are used to create a lower and upper bound. These bounds are 2 to the power of i and 2 to the power of j minus 1 respectively. These bounds are then passed to the `generate_random_bits(lower_bound, upper_bound, number_of_bits)` function which generates the key that gets passed to `bit_str_xor(bit_str_1, bit_str_2)` to encrypt the flag. The `generate_random_bits(lower_bound, upper_bound, number_of_bits)` will carry on generating random numbers until it has a bit string of length of `number_of_bits`. The `randint(a,b)` function generates a random integer between a and b inclusive.

The other important function to take note of is the `bin()` function. This function returns a bit string of the integer argument without any trailing 0's. This means that the first bit of the bit string will always be a 1. This is key to solving this challenge. 

What is evident is that through the input we can control how many bits the random number generated by `randint(a,b)` will be. A decimal integer x can be represented by b bits if `2**(b-1) <= x <= (2**b)-1`. For example, if we provide the input of i=3 and j=4 we will generate only use 4 bit random numbers to generate the key. Since we know that the `bin()` function returns a bit string with the first bit as 1 we know that for a 4 bit integer the *1st, 5th, 9th ...* bits of the key will also be 1's. Therefore we can use this to recover the *1st, 5th, 9th ...* bits of the plaintext. If the *1st, 5th, 9th ...* bit of the ciphertext is a 1 then the plaintext bit must be 0 since 0 XOR 1 = 1 and if the ciphertext bit is 0 then the plaintext bit must be 1 since 1 XOR 1 = 0.

Hence to use this to solve this challenge we can use the following algorithm:
1. Start with an input of `i=1, j=2`. This will generate a key by repeating a 2 bit number.
2. Look at the 3rd bit of the ciphertext and derive the third bit of the plaintext.
3. Next increment i and j by 1 and repeat the process to recover the 4th bit of the plaintext.
4. Continue in this manner until all bits are recovered.

The only bits that cannot be recovered this way is the first and second bit, but we know that these need to be 1 since the first letter of *flag* is *f* which has a binary representation of *1100110*

Note that a more efficient way to recover the plaintext is to only use keys that are a prime number of bits long. This is because the key is generated by repeatedly generating *n* bit integers meaning that you can use a *n* bit number to recover all bits that are a multiple of *n*. This is how I implemented it in `decrypt.py` using all prime numbers less than 301.

Running `decrypt.py` gives the flag as: `flag{bits_leaking_out_down_the_water_spout}`